i first realised that for bitwise and operator between any 2 elements to always give n, in the binary representation of n, all the 0s can be a 1 only once (in only one other number) because if that spot was 1 in 2 numbers, the bitwise and would give a 1 there which wont give n. so i basically replace a 0 with a 1 making a new number one at a time, going with smallest first, and checking at each step to make sure the number hasnt exceeded m. to do this, i reverse the binary representation of n, check for 0s, convert it to 1. inrease a counter so that next time, it parses through 2 zeroes and converts the second 0 to 1 making a diff number and so on.And i check every time that it hasnt exceeded m.
I also have a vector where I store all numbers obtained from converting some 0 to 1, so that I can give a sequence which follows the properties.
